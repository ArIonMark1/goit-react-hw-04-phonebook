 У кожного компонента реакту є три фази життєвого циклу
 1 монтування - componentDidMount
 2 Оновлення - componentDidUpdate(prevProps, prevState, *snapshot) '*' - не обов'язковий параметр 
 3 Розмонтування - componentWillUnmount

МОНТУВАННЯ
    Виконується один раз за весь життєвий цикл.
    Спочатку викликається метод-конструктор самого класу
    Далі викликається метод рендеру
    Потім Реакт обновляє DOM
    Після цього викликається метод componentDidMount(), цей метод викликається один раз за весь життєвий цикл компонента
    Можемо в компоненті глянути як працюють ці методи: 
    
    Всередині компоненту прописуємо:
    export default class Component extends React.Component {
        
        componentDidMount() {
            console.log('Component mounted.')
        }   
        render() {...}
    }


ОНОВЛЕННЯ
    Оновлення компоненту відбувається коли приходять нові пропси або змінюється стейт
    На кодному оновленні компоненту викликається метод componentDidUpdate()

РОЗМОНТУВАННЯ
    Коли ми видяляємо якийсь елемент із DOM він розмонтовується, за це відповідає 
    метод componentWillUnmount() виконується для очистки за собою

Також є ще три методи які майже ніколи ніхто не використовує це: 
    * getDerivedStateFromProps
    * shouldComponentUpdate
    * getSnapshotBeforeUpdate

Для оптимізації хороший метод який забороняє компоненту оновлюватись:
    shouldComponentUpdate()


Приклади роботи з методами компонента
    Якщо у нас при оновлені компонента попередній стейт не рівний попередньому стейту

     if (this.state.todos !== prevState.todos) {
        console.log('Оновилось поле todos.')
        localStorage.setItem('todos', JSON.stringify(this.state.todos));
     }

Також цікавий приклад повернення та запис значень до стейту. Коли користувач заходить на 
сайт та немає ніяких записів у базі даних(наразі ЛокалСторедж), тоді при запиті даних
користувача повернеться null і проект "впаде", тому при монтуванні ми будемо перевіряти чи
приходять якісь значення, якщо ні то не робимо запит, це все робимо за допомогою
componentDidMount() так як він відпрацьовує один тільки раз при монтуванні компоненту

/*...*/

componentDidMount() {
    const todos = localStorage.getItem('todos');
    const parsedTodos = JSON.parse(todos);

    if (parsedTodos) {
        this.setState({ 'todos': parsedTodos })
    }
}

Гарний тон написання логіки компонента: 
    компоненти(методи) життєвого циклу завжди ставте їх після стейту а в кінці кастомні методи.

__ПОРТАЛИ__

    Беремо реакт компонент і рендеримо його в зовсім інший html-елемент.
    Робимо рут-елемент у файлі index.html який лежить у /publick/index.html
    
    <body>
        <div id="root"></div>
        <div id="modal-root"></div>
    </body>

    Далі у файлі модалки пишемо наступний код: 

        ****************************************
        import { createPortal } from 'react-dom';

        const modalRoot = document.querySelector('modal-root'); - ok
        ****************************************
    І далі в методі не повертаємо просто розмітку у методі рендеру, а повертаємо виклик порталу в якому
    першим аргументом повертаємо нашу розмітку а бругим параметром передаємо посилання на 
    корінь модалок: 
        ****************************************
        export default class Modal extends React.Component {
            /*...*/
            render () {
                return createPortal(
                    <div className="Modal__backdrop">
                        <p>Content</p>
                        <div className="Modal__content">{this.props.children}</div>
                    </div>,
                    modalRoot
                );
            }
        }
        ****************************************


Щоби виконати закривання модалки по натисканню на кнопку, потрібно зробити слухача подій, але реакт
не має такої механіки як відслідковування подій, для цього існує спеціальний підхід.
Ми можемо вирішити цю проблему за допомогою componentDidMount(), як раз тут ми можемо використати 
відслідковування подій, створити слухача подій на вікні.

    componentDidMount() {

        window.addEventListener('keydown', evt => {
            if (evt.code === 'Escape') {
                this.props.onClose();
            }
        })
    }

Але лишається проблема що по кнопкі ми можемо натискати безліч разів і зареєструється
бескінечна кількість викликів функції, також може що функція і не спрацює
але вся сторінка через безкінечну кількість викликів зависне. Тому тут на допомогу прийде
метод componentWillUnmount() який і буде розмонтовувати, видаляти, функцію 
виклику закривання модалки: 
    componentWillUnmount() {

        window.removeEventListener('keydown', this.handleKeyDown)
    }

    handleKeyDown = evt => {
    if (evt.code === 'Escape') {
      console.log('Pressed ESCAPE button.');

      this.props.onCloseModal();
    }
  };

Такий підхід феноменально впливає на продуктивність проекту в цілому!!!


МЕТОД ЖИТТЄВОГО ЦИКЛУ 
    shouldComponentUpdate()
    наприклад маємо вікно із вкладками при натисканні на які будуть вспливати якісь інформаційні вікна,
    так от щоби при натисканні на одну і ту ж вкладку вікно не перемальовувалось та не навантажувало код 
    використовуємо даний код, який буде тільки по якійсь умові перемальовувати наше вікно
            
            shouldComponentUpdate(поточний_стейт, наступний_стейт ) 

            shouldComponentUpdate(nextProps, nextState) {
                return nextState.activeTabIdx !== this.state.activeTabIdx;
            }
    Даний метод дуже тяжкий для системи, тому його використання вкрай рідкісне але є чудова альтернатива
    у Реакті це PureComponent. Замість розширення нашого компонента від Component  ми розширюємо наш компонент
    від PureComponent у якого під капотом вже йде зрівняння всіх поверніх пропсів а також вмонтований shouldComponentUpdate

            import React, {PureComponent} from 'react';

            export default class Component extends PureComponent {...}



   !!!! всі іконки будемо зберігати в папкі біля папки компонентів
        після цього заімпортуємо картинку(.svg) як реакт компонент:
             import {ReactComponent as MyName } from './icons/picture.svg'
        
        далі рендеримо нашу картинку як реакт-компонент: <MyName />
        та можемо передавати їй параметри   <MyName width='40' height='40' fill='red' />

    Створемо кнопку-іконку: 

        export default const IconButton = ({children, onClick, ...allyProps }) => (
            <button type="button" className="IconButton" onClick={onClick} {...allyProps}>
            {children}
            </button>
        );

        IconButton.defaultProps = {
            onClick: () => null,
            children: null,
        };

        IconButton.propTypes = {
            onClick: PropTypes.func,
            children: PropTypes.node,
            'aria-label': PropTypes.string.isRequired,
        }

        І далі кпи виклику компонента кнопки ми будемо їй передавати картинку:
        
            <IconButton onClick={this.toggleModal}>
                <AddIcon width="40" height="40" fill="#fff" />
            </IconButton>